

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SECTION 9. BASIC GRAPHES ALGORITHMS &#8212; Data Structures and Algorithms. Hybrid approach (DRAKON + GOLANG)</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Engl_md_prime/section_9';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    DATA STRUCTURES AND ALGORITHMS HYBRID IMPLEMENTATION (DRAKON + GOLANG)
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../Engl_md/section_1.html">SECTION 1. ABSTRACT DATA TYPES (ADT)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Engl_md/section_2.html">SECTION 2. GOLANG PROGRAMMING LANGUAGE OVERVIEW</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Engl_md/section_3.html">SECTION 3. DRAKON - VISUAL ALGORITHMIC LANGUAGE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Engl_md/section_4.html">SECTION 4. IMPLEMENTATION OF BASIC ABSTRACT DATA TYPES IN GOLANG</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Engl_md/section_5.html">SECTION 5. COMPLEXITY AND STABILITY ANALYSIS OF ALGORITHM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Engl_md/section_6.html">SECTION 6. BASIC SORTING ALGORITHMS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Engl_md/section_7.html">SECTION 7. BASIC SEARCH ALGORITHMS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Engl_md/section_8.html">SECTION 8. BINARY TREE ALGORITHMS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Engl_md/section_9.html">SECTION 9. BASIC GRAPHES ALGORITHMS</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/ISA-1941/drakongogit.git" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/ISA-1941/drakongogit.git/issues/new?title=Issue%20on%20page%20%2FEngl_md_prime/section_9.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/Engl_md_prime/section_9.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>SECTION 9. BASIC GRAPHES ALGORITHMS</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#general-information-basic-terminology">9.1. General information. Basic terminology</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-representation-methods">9.2. Graph representation methods</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithms-of-graph-traversal-search">9.3. Algorithms of graph traversal (search)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-depth-first-search-algorithm">9.3.1. The depth-first search algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-breadth-first-search-algorithm">9.3.2. The breadth-first search algorithm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-a-path-between-vertices-in-a-directed-graph-3">9.5. Choosing a path between vertices in a directed graph#3</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithm-for-determining-the-minimum-number-of-edges-between-two-nodes">9.6. Algorithm for determining the minimum number of edges between two nodes</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <div class="tex2jax_ignore mathjax_ignore section" id="section-9-basic-graphes-algorithms">
<h1>SECTION 9. BASIC GRAPHES ALGORITHMS<a class="headerlink" href="#section-9-basic-graphes-algorithms" title="Permalink to this heading">#</a></h1>
<div class="section" id="general-information-basic-terminology">
<h2>9.1. General information. Basic terminology<a class="headerlink" href="#general-information-basic-terminology" title="Permalink to this heading">#</a></h2>
<p>This section covers the topic of graphs as data structure.A graph is a collection of vertices and edges that are connected by nodes. In general, graphs share many similarities with trees, and one can consider trees as a special case of graphs. However, the practical value of graphs in solving real-world problems is much greater. Many tasks can be reduced to considering a set of objects whose properties are described by the relationships between them. Such objects include electrical and electronic circuits, circuit boards, road maps, aviation routes, descriptions of constructions, and games. Among the tasks that can be solved using graphs are finding the shortest path between two vertices, solving the problem of maximum capacity of pipelines, road networks, or computer networks, distributing N workers to perform M different types of work, and choosing the most efficient method of problem solving, among others.
A graph is a collection of vertices and edges that are connected by nodes. The graph <em>G</em> is completely defined by the set of vertices <em>{V}</em> and the set of edges <em>{E}</em> that connect all or part of these vertices. If edges are oriented, which is usually shown by an arrow, then they are called arcs, and the graph with such edges is called a directed graph (Figure 9.1 a). If edges have no orientation, then the graph is called undirected.</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_1_all.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_1_all.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_1_all.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.1. The view of a) -undirected;
 - directed</p>
<p>The elements of a graph are called vertices and edges. The number of vertices in the graph is called the order, and the number of edges is called the size of the graph. The endpoints of an edge <em>e = {u,v}</em> are called vertices <em>(u,v)</em>, and two endpoints of the same edge are called adjacent. Two edges are called adjacent if they have a common endpoint. Two edges are called multiples if the sets of their endpoints are the same. An edge is called a loop if its ends coincide, that is, e = {u,u}. If the vertex is the beginning or end of the edge, then they (vertex and edge) are incident. The number of edges incident to a vertex is called the vertex degree (Figure 9.2).</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_2_Ter.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_2_Ter.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_2_Ter.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.2. Basic graph parameters</p>
</div>
<div class="section" id="graph-representation-methods">
<h2>9.2. Graph representation methods<a class="headerlink" href="#graph-representation-methods" title="Permalink to this heading">#</a></h2>
<p>Solving problems related to the processing of a data set organized in the form of graphs requires their modelling in computer programs. In principle, a set of vertices can be stored in an array and accessed by index. You can also store vertices using a simple-linked list or other data structure. In practice, two structures are typically used to model the structure of a graph: the adjacency matrix and the adjacency list. Adjacent in the sense that such vertices are connected by one edge.
Adjacency matrix is a two-dimensional array that indicates the existence of a relationship between two vertices. If the graph has <em>V</em> vertices, then the adjacency matrix is a <em>V × V array</em>. Figure 9.3 shows undirected and directed graphs with adjacency matrices, where (1) denotes the presence of an adjacent relationship between vertices. For instance, in an undirected graph, vertex (2) is adjacent to vertices (1), (3), (4), and (5), while in a directed graph, vertex (2) is adjacent to vertices (1), (3), and (4).</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_3_T_UD.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_3_T_UD.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_3_T_UD.jpg" style="width: 400px;" /></a>
<p style="text-align: center;">Figure 9.3. Graph representation in the adjacency matrix</p>
<p>Graphs are used to solve many real-life problems. They are used to represent networks, including paths in a city or telephone network or circuit network. Graphs are also used in social networks like LinkedIn and Facebook. For example, in Facebook, each person is represented with a vertex (or node). Each node is a structure and contains information like person id, name, gender, locale, etc. Many tasks can be reduced to considering a set of objects whose properties are described by the relationships between them. Among the tasks that can be solved using graphs are finding the shortest path between two vertices, solving the problem of maximum capacity of pipelines, road networks, or computer networks, distributing N workers to perform M different types of work, and choosing the most efficient method of problem solving, among others.</p>
<p>The representation of a graph in the adjacency matrix is problematic. Foremost, when constructing a matrix, it is necessary to know in advance the number of vertices in the graph, which leads to the need to build a new matrix each time new vertices are inserted. In addition, the adjacency matrix consists mainly of zeros, resulting in inefficient memory usage, and if the graph contains V vertices, then memory for V^2 elements must be allocated 1.
In some cases, a more efficient way to represent a graph is to use an adjacency list. More precisely, we are talking about arrays of Linked  lists, where each individual list contains information about which vertices are adjacent to a given one. Undirected and directed graphs and their adjacency lists are depicted in Figure 9.4.</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_4_SS_UD.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_4_SS_UD.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_4_SS_UD.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.4. Graph representation in a adjacency list</p>
<p>As you can see, in the matrix and list, the adjacency for an undirected label (1) is applied to all adjacent vertices. However, for a directed graph, label (1) is applied only to the vertices pointed to by the arc of the adjacent vertex. At the same time, it should be taken into account that in some cases, such as dense matrices, a matrix representation is preferable to a list of adjacent vertices.
As can be seen, the spatial complexity of directed and undirected graphs depends on its representation: for a matrix graph – O(N*N), for a list representation – O(N+M), where N is the number of vertices, M is the number of edges. In practice, it is possible to use both kinds of graph representations, but it is useful to use an  adjacency matrix to represent dense graphs  and an adjacency list to represent sparse graphs. Dense graphs are graphs that have a large number of edges, while sparse graphs are those that have a small number of edges.
To build a graph in the Golang language, you need to create new types, the content of which is determined by a specific task and the choice of basic data structures from which new types will be created. Of course, all new types are created based  on the basic struct structure, but the number and content of its fields depend on the type of graph. In particular, a description of a loaded graph whose edges are marked, for example, by the distance between vertices,  should include a weight  field (Fig. 9.5.):</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_5_load.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_5_load.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_5_load.jpg" style="width: 150px;" /></a>
<p style="text-align: center;">Figure 9.5. Weighted graph</p>
<p>In the simplest case, work with graphs requires the inclusion of fields for vertices and/or edges in the structure. To create a Graph type with support for graph representation using the list of adjacencies, use different basic structures of the language Golang (two-dimensional slices, maps, cuts, elements of which are simply connected lists [Korman T. X. etc. Algorithms: construction and analysis, 3rd d. - M.: LLC “J.D. Williams”, 2013.   P.626. ]. Next we will use types: to describe the vertices, to list the adjacent vertices, and to describe the graph (Table. 9.1.):</p>
<p style="text-align: right;">Table. 9.1. Several types of graph algorithms</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Types.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Types.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Types.jpg" style="width: 500px;" /></a>
</div>
<div class="section" id="algorithms-of-graph-traversal-search">
<h2>9.3. Algorithms of graph traversal (search)<a class="headerlink" href="#algorithms-of-graph-traversal-search" title="Permalink to this heading">#</a></h2>
<p>Due to the widespread use of graphs, there are many algorithms for processing them. Problems solved within the framework of graph theory can be
conventionally divided into several groups:</p>
<p>• Definition of a graph and its properties;
• Actions with graphs;
• Routes, circuits and cycles, contours;
• Calculation of graph characteristics;
• Tasks on graphs.</p>
<p>Consider the main algorithms used in these problems and implemented, as before, within the framework of hybrid programming DRAKON+Golang.</p>
<p>After a graph is constructed and its properties tested, it is natural to
traverse its vertices. The general problem is formulated as follows: to
circumvent the graph, starting at a given vertex and moving along the
edges to other vertices, visit all vertices connected to the original.
There are two main ways to circumvent graphs: depth traversal and width
traversal, which provide a brute-force of all connected vertices.</p>
<p>The difference between depth search and width search is that (in the
case of an undirected graph), the result of a depth-first search
algorithm is some route by which it is possible to circumvent
sequentially all vertices of the graph available from the initial
vertex. This is fundamentally different from a breadth search, where
multiple vertices are simultaneously processed, and only one vertex is
processed in depth at each time. On the other hand, depth-first searches
do not find the shortest paths, but they do apply to situations where
the graph is unknown in its entirety and is investigated by some
automated device.</p>
<div class="section" id="the-depth-first-search-algorithm">
<h3>9.3.1. The depth-first search algorithm<a class="headerlink" href="#the-depth-first-search-algorithm" title="Permalink to this heading">#</a></h3>
<p>Depth-first search algorithm (DFS) allows constructing a traversal of a
directed or undirected graph that visits all vertices accessible from
the initial vertex. The choice of depth-first search is justified in
situations where it is necessary to investigate the unknown structure of
a real object represented as a graph. If the graph is directed, then
depth-first search builds a tree of paths from the initial vertex to all
accessible from it. In practice, depth-first crawling is used in the
analysis of options for choosing further behaviour in games.</p>
<p>Depth-first search can be thought of in this way. Let an observer
located at one of the vertices of the graph be given the task of
visiting all its vertices. Being at this vertex, the observer sees the
edges emanating from this vertex. In the case of a sufficiently complex
structure, the graph observes the risk of developing some vertices
several times and, in the end, looping. To avoid this situation, the
observer should mark all visited vertices and should not go to the
vertex that he has already visited. The algorithm may look like this:</p>
<ul class="simple">
<li><p>Select the vertex from which the graph traversal begins;</p></li>
<li><p>Go to the next neighboring vertex not visited before;</p></li>
<li><p>Run from this vertex the traversal bypass algorithm;</p></li>
<li><p>Return to the starting vertex;</p></li>
<li><p>Repeat the process for all previously unvisited adjacent vertices.</p></li>
</ul>
<p>Thus, to implement the algorithm, you will need to note which vertices
the researcher was at and which vertices he was not at. The annotation
will be made in the visited list, where <em>visited[i] == True</em> for
visited vertices, and <em>visited[i] == false</em> for unvisited ones. The
mark “about visiting vertices” is placed when entering this vertex.
Since the purpose of depth traversal is often to construct a depth
traversal tree, the preceding vertices are retained for each active
vertex.<br />
The depth-first search algorithm takes the form of a recursive function
(<em>DFS</em>), where <em>start</em> is the number of the vertex from which the
traverse is started. Depth-first search starts by visiting the original
vertex vi, after which all adjacent vertices are visited recursively. A
visit to a vertex is recorded in the logical array visit. The
depth-first search algorithm is based on the use of a recursive function
that pops a vertex from the stack, checking it for attendance. If the
vertex has already been visited, the traversal continues the search
through the adjacency list until a dead vertex is reached. An
illustration of the graph bypass in depth is shown in Figure 9.7.</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_7Eng.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_7Eng.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_7Eng.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.7. Depth-first search of the graph by adjacency list</p>
<p>The DRAKON-diagram of depth-first search algorithm is represented in
Figure 9.8.</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_8ER.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_8ER.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_8ER.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.8. The DRAKON-diagram of depth-first search algorithm; . The breadth-first search algorithm</p>
</div>
<div class="section" id="the-breadth-first-search-algorithm">
<h3>9.3.2. The breadth-first search algorithm<a class="headerlink" href="#the-breadth-first-search-algorithm" title="Permalink to this heading">#</a></h3>
<p>Breadth-first search is carried out like a propagating wave, starting
from visiting the original vertex, which is chosen arbitrarily. Then you
visit the neighbouring peaks, and then you visit the neighbours, and so
on. Sometimes this traversal is compared to the spread of fire through
adjacent vertices: first, the vertices that are adjacent to the original
vertex are ignited, then the same is the same with respect to the other
vertices.</p>
<p>Breadth-first search can be explained differently, more formally.
Traversal occurs as the distance from the initial vertex increases.
Here, the distance is determined by the number of edges between the
vertices: in particular, the distance between adjacent vertices relative to the reference is 1 (Figure 9.9):</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_9_ER.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_9_ER.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_9_ER.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.9. Distance from the original vertex</p>
<p>An illustration of breadth-first search using the example of the
Hamiltonian graph is given in Figure 9.10:</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_10_Eng.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_10_Eng.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_10_Eng.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.10. Breadth-first search of graph (wave traversal)</p>
<p>The DRAKON-diagram of the graph traversal algorithm is represented in Figure 9.11.</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_11E.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_11E.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_11E.jpg" style="width: 400px;" /></a>
<p style="text-align: center;">Figure. 9.11. DRAKON-diagram of Breadth-first traversal algorithm</p>
<p>Since the algorithm of breadth-first traversal is quite complicated,
consider it in more detail. Firstly, let’s pay attention to the entered types of variables:<br />
а) <em>type Vertices</em> - for the information structure of a vertex; consists of three fields: <em>data int</em> - vertex key (in this case its number), <em>next</em> - address of the first adjacent vertex of the graph, <em>last</em> - address of the last adjacent vertex of the graph:</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_a.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_a.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_a.jpg" style="width: 400px;" /></a>
<p>b) type <em>AjlistNode</em> – for a single vertex, the actual structure of the single linked list;</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_b.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_b.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_b.jpg" style="width: 300px;" /></a>
<p>c) type <em>QNode</em> – for a queue element whose structure looks like:</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_c.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_c.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_c.jpg" style="width: 300px;" /></a>
<p>d) type <em>MyQueue</em> - for &lt;queue&gt; variable whose structure looks like:</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_d.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_d.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_d.jpg" style="width: 300px;" /></a>
<p>e) type <em>Graph</em> – for variable, representing graph structure: <em>size</em> -
number of vertices, <em>node –</em> slice, containing addresses of adjacent vertices:</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_e.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_e.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_Table_e.jpg" style="width: 300px;" /></a>
<p>The algorithm for breadth-first traversal begins with the selection of the original vertex, let this vertex be marked as “0” (Figure 9.10).
This vertex should be placed in <em>a queue</em> queue of type *MyQueue:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span>var queue \* MyQueue = &amp;MyQueue {nil,nil,0}
</pre></div>
</div>
<p>The queue structure is associated with the enqueuing method,
queue.enqueue(point), where point is the vertex key (Figure 9.12).</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_12_ER.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_12_ER.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_12_ER.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.12. DRAKON-diagram of the *queue.enqueue* method</p>
<p>In the enqueue module, the new element of queue as an instance of a nodestructure of type QNode is a singly linked list. Next, the address of the next node is checked for the head element, and if it is equal tonil, then this node is assigned the value node, thus forming the nodes of the queue <em>queue</em>. If it is not equal to nil, then the value of node is assigned to the last element of the queue: <em>queue.tail.next = node</em>.
In this case, the <em>queue.count</em> queue length is increased by 1.</p>
<p>Deleting a vertex from the queue is implemented by dequeue, associated with the queue instance whose algorithm DRAKON-diagram is shown in Figure 9.13:</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_13_ER.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_13_ER.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_13_ER.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.13. DRAKON-diagram of method *queue.dequeue*</p>
</div>
</div>
<div class="section" id="choosing-a-path-between-vertices-in-a-directed-graph-3">
<h2>9.5. Choosing a path between vertices in a directed graph#3<a class="headerlink" href="#choosing-a-path-between-vertices-in-a-directed-graph-3" title="Permalink to this heading">#</a></h2>
<p>The choice of a path between two vertices in a directed graph, which is of practical importance in the sense of finding the optimal path between two settlements connected by one-way roads, can be carried out according to various criteria. Dijkstra’s algorithm is well known, which determines the minimum distance between two given nodes of a graph.
Let’s complicate this task a little: in order to determine the optimal path, find the distances of all possible paths between two geographical points, as well as the total fare, taking into account the different cost per 1 km on different sections of the road.</p>
<p>To solve this problem, it is necessary to create a weighted graph, more specifically, to load the edges between all vertices with the values of the distances between the points and the fare per 1 kilometre (Figure 9.14).</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_14_Eng.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_14_Eng.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_14_Eng.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.14. Weighted directed graph with source data</p>
<p>The algorithm for finding all possible paths between two vertices is
based on the sequential analysis of the list of vertex connections and recursive access to the <em>findPath</em> module, which implements a traversal of nodes with fixing a visit to each vertex. The DRAKON-diagram for the <em>findPath</em> module is shown in Figure 9.13. The algorithm consists of three parts: in the first part, the correctness of the module parameters (the names of the initial and final vertices) is set, and the fact of visiting the current vertex is checked. The second part traverses through the nodes of the graph that have not yet been visited, forming a string consisting of visited vertex names and a separator between them, for example, “2-0-1-4-3-5” (Figure 9.15). In the third part, when the final vertex is reached, that is, when the condition <em>“start == last”</em>
is met, the minimum path between these vertices is determined. In
addition, a possible path string, for example, “2-0-1-4-3-5”, is
divided into sections of the type “2-0” in order to form keys for maps containing the distances between the corresponding vertices and the cost of travelling 1 km, these areas.</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_15_Eng.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_15_Eng.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_15_Eng.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.15. DRAKON-diagram of method *findPath*</p>
<p>Consider the problem of finding all possible paths between two vertices of the graph shown in Figure 9.16:</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_16_Eng.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_16_Eng.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_16_Eng.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.16. Graph and the adjacency list</p>
<p>The algorithm implementation process is shown in Table 9.2. The
“stack” column shows the number of recursive calls to the <em>findPath</em> module, whose parameters are: initial (<em>start int</em>) and final (<em>last int</em>) vertices, path (<em>path string</em>) and slice of logical states of visiting vertices (<em>visit[] bool</em>). The “start” column displays the keys of the current vertices, the “<em>edgePrev</em>” column displays a singly linked list that contains the name of the current vertex and its address, as well as the address of the next entry, and the “<em>edge</em>” column displays the name and address of the next entry. The algorithm, using the adjacency list, passes, if the condition (<em>edge != nil</em>) is
met, in a loop through the corresponding vertices of the graph, filling, if the condition (edge == nil) is met, the contents of the stack.</p>
<p style="font-size:14px;text-align:right;">Table.9.2. Method of implementation process *findPath*</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_17_Table.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_17_Table.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_17_Table.jpg" style="width: 400px;" /></a>
<p style="text-align: center;">a)</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_17_Ways.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_17_Ways.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_17_Ways.jpg" style="width: 300px;" /></a>
<p style="text-align: center;"></p>
<p style="text-align: center;">Figure 9.17. Output of implementation method findPath</p>
</div>
<div class="section" id="algorithm-for-determining-the-minimum-number-of-edges-between-two-nodes">
<h2>9.6. Algorithm for determining the minimum number of edges between two nodes<a class="headerlink" href="#algorithm-for-determining-the-minimum-number-of-edges-between-two-nodes" title="Permalink to this heading">#</a></h2>
<p>In the previous subsection, the algorithm of finding all possible ways of moving from one vertex to another was considered. It can be seen that the number of edges in the different pathways varies from 3 to 5. Next, consider the algorithm for determining the minimum number of edges between two vertices (Figure 9.18):</p>
<div style="page-break-before: always;"></div>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_18_minEdges.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_18_minEdges.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_18_minEdges.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.18. DRAKON-diagram of the minimum number of edges algorithm</p>
<p style="font-size:14px;text-align:right;">Table. 9.3. Process of module implementation *find*</p>
<a class="reference internal image-reference" href="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_19_Table.jpg"><img alt="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_19_Table.jpg" class="align-center" src="C:/Users/ISA_PC/.jupyter/projectBook/drakongo/Engl_images/E_Im9/Fig9_19_Table.jpg" style="width: 300px;" /></a>
<p style="text-align: center;">Figure 9.19. DRAKON-diagram of the minimum number of edges algorithm</p></div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Engl_md_prime"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#general-information-basic-terminology">9.1. General information. Basic terminology</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-representation-methods">9.2. Graph representation methods</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithms-of-graph-traversal-search">9.3. Algorithms of graph traversal (search)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-depth-first-search-algorithm">9.3.1. The depth-first search algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-breadth-first-search-algorithm">9.3.2. The breadth-first search algorithm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-a-path-between-vertices-in-a-directed-graph-3">9.5. Choosing a path between vertices in a directed graph#3</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithm-for-determining-the-minimum-number-of-edges-between-two-nodes">9.6. Algorithm for determining the minimum number of edges between two nodes</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Ivanov S.
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>