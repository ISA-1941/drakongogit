// Autogenerated with DRAKON Editor 1.31

package main 
 
import ( 
    "fmt" 
) 
 
const SIZE = 15 
type Node struct { 
    Value int 
    Next  *Node 
} 
type HashTable struct { 
    Table map[int]*Node 
    Size  int 
} 



func  hashFunc(i, size int) int {
    // item 78
    return i % size
}

func  hashInsert(hash *HashTable, value int) int {
    // item 15
    index := hashFunc(value, hash.Size)
    // item 16
    element := Node{Value: value, 
    Next: hash.Table[index]}
    // item 17
    hash.Table[index] = &element
    // item 14
    return index
}

func  hashLookup(hash *HashTable, value int)  {
    // item 40
    index := hashFunc(value, hash.Size)
    // item 41
    if hash.Table[index] != nil {
        // item 44
        t := hash.Table[index]
        for {
            // item 68
            if t != nil {
                
            } else {
                break
            }
            // item 47
            if t.Value == value {
                // item 123
                fmt.Println(value, "- is exist")
                return
            } else {
                
            }
            // item 77
            t = t.Next
        }
    } else {
        
    }
    // item 52
    fmt.Println("After removing ",
     value, "- does not exist")
    return
}

func  hashLookup_2(hash *HashTable, value int)  {
    // item 129
    index := hashFunc(value, hash.Size)
    // item 130
    if hash.Table[index] != nil {
        // item 132
        t := hash.Table[index]
        for {
            // item 135
            if t != nil {
                
            } else {
                break
            }
            // item 133
            if t.Value == value {
                // item 145
                fmt.Println(value, "присутствует")
                return
            } else {
                
            }
            // item 142
            t = t.Next
        }
    } else {
        
    }
    // item 134
    fmt.Println(value, "отсутствует")
    return
}

func  hashRemove(hash *HashTable, value int)  {
    // item 151
    var node, nodePrev *Node
    // item 152
    index := hashFunc(value, hash.Size)
    // item 153
    if hash.Table[index] == nil {
        // item 156
        return
    } else {
        
    }
    // item 157
    node = hash.Table[index]
    for {
        // item 158
        if node != nil {
            
        } else {
            break
        }
        // item 160
        if node.Value == value {
            // item 163
            nodePrev.Next = node.Next
        } else {
            
        }
        // item 165
        nodePrev = node
        node = node.Next
    }
}

func  hashTravers(hash *HashTable)  {
    for key := range hash.Table {
        // item 26
        if hash.Table[key] != nil {
            // item 29
            t := hash.Table[key]
            for {
                // item 32
                t = t.Next
                // item 65
                if t != nil {
                    
                } else {
                    break
                }
                // item 33
                fmt.Print(" : ", t.Value)
            }
        } else {
            
        }
        // item 90
        fmt.Println()
    }
}

func  main()  {
    // item 57
     table := make(map[int]*Node, SIZE)
    // item 58
    hash := &HashTable{Table: table, Size: SIZE} 
    //fmt.Println("Number of spaces:", hash.Size)
    // item 590001
    i := 0;
    for {
        // item 590002
        if i < 120 {
            
        } else {
            break
        }
        // item 61
        hashInsert(hash, i)
        // item 590003
        i++;
    }
    // item 63
    hashLookup(hash,74)
    // item 167
    hashRemove(hash, 74)
    // item 122
    // After removing 74 
    hashLookup(hash, 74)
}


