// Autogenerated with DRAKON Editor 1.31

package main
import "fmt"
/*
    Go Program for 
    Breadth first traversal in directed graph
*/
type AjlistNode struct {
    // Vertices node key
    id int
    next * AjlistNode
}
type Vertices struct {
    data int
    next * AjlistNode
    last * AjlistNode
}
type QNode struct {
    data int
    next * QNode
}
type MyQueue struct {
    head * QNode
    tail * QNode
    count int
}
type Graph struct {
    // Число вершин
    size int
    node []* Vertices
}



func  (Que  *MyQueue) dequeue() int {
    // item 61
    if Que.head == nil {
        // item 64
        fmt.Println("Empty Queue")
        return -1
    } else {
        
    }
    // item 65
    var temp * QNode = Que.head
    // item 66
    Que.head = Que.head.next
    Que.count--
    // item 69
    if Que.head == nil {
        // item 72
        Que.tail = nil
    } else {
        
    }
    // item 73
    return temp.data
}

func  (Que  MyQueue) size() int {
    // item 36
    return Que.count
}

func  (Que *MyQueue) enqueue(value int)  {
    // item 48
    var node * QNode = &QNode {value,nil}
    // item 49
    if Que.head == nil {
        // item 52
        Que.head = node
    } else {
        // item 53
        Que.tail.next = node
    }
    // item 54
    Que.count++
    // item 55
    Que.tail = node
}

func  (Que MyQueue) isEmpty() bool {
    // item 42
     return Que.count == 0
}

func  (Que MyQueue) peek() int {
    // item 79
    if Que.head == nil {
        // item 82
        fmt.Println("Empty Queue")
        return -1
    } else {
        // item 83
        return Que.head.data
    }
}

func  (g  *Graph) addEdge(start, last int)  {
    // item 125
    if start >= 0 && start < g.size && 
last >= 0 && last < g.size {
        // item 128
         var edge * AjlistNode = &AjlistNode {last,nil}
        //getAjlistNode(last)
        // item 129
        if g.node[start].next == nil {
            // item 132
            g.node[start].next = edge
        } else {
            // item 133
            g.node[start].last.next = edge
        }
        // item 212
        g.node[start].last = edge
    } else {
        // item 137
        fmt.Println("\nHere Something Wrong")
    }
}

func  (g  *Graph) setData()  {
    // item 95
    if g.size <= 0 {
        // item 98
        fmt.Println("\nEmpty Graph")
    } else {
        // item 990001
        index := 0;
        for {
            // item 990002
            if index < g.size {
                
            } else {
                break
            }
            // item 101
            g.node[index] =
            getVertices(index)
            // item 990003
            index++;
        }
    }
}

func  (g Graph) bfs(point int)  {
    // item 191
    if point > g.size || g.size <= 0 {
        // item 193
        return
    } else {
        
    }
    // item 194
    var q * MyQueue = &MyQueue {nil,nil,0} 
    // getMyQueue()
    // item 232
    var k int = 0
    var p = make([] int, g.size)
    // item 195
    q.enqueue(point)
    // item 219
    var temp * AjlistNode = nil
    var visit = make([] bool, g.size)
    for {
        // item 198
        if q.isEmpty() == false {
            
        } else {
            break
        }
        // item 228
        if q.head == nil {
            // item 231
            fmt.Println("Empty Queue")
            return
        } else {
            // item 201
            temp = g.node[q.head.data].next
        }
        for {
            // item 202
            if temp != nil {
                
            } else {
                break
            }
            // item 205
            if !visit[temp.id] {
                // item 207
                visit[temp.id] = true
                q.enqueue(temp.id)
            } else {
                
            }
            // item 209
            temp = temp.next
        }
        // item 220
        // item 210
        visit[q.head.data] = true
        // item 211
        p[k] = q.dequeue()
        fmt.Println("\np = ", p)
        k++
    }
}

func  (g Graph) printGraph()  {
    // item 151
    if g.size > 0 {
        // item 1540001
        index := 0;
        for {
            // item 1540002
            if index < g.size {
                
            } else {
                break
            }
            // item 156
            fmt.Print("\nAdjacency list of vertex ", 
                            index, " : ")
            // item 157
            var temp * AjlistNode = 
            g.node[index].next
            for {
                // item 158
                if temp != nil {
                    
                } else {
                    break
                }
                // item 161
                fmt.Print("  ", g.node[temp.id].data)
                // item 162
                temp = temp.next
            }
            // item 1540003
            index++;
        }
    } else {
        
    }
}

func  getAjlistNode(id int) *AjlistNode {
    // item 12
    return &AjlistNode {id,nil}
}

func  getGraph(size int) * Graph {
    // item 89
    var me *Graph = 
    &Graph {size,make([]*Vertices, size)}
    // item 90
    me.setData()
    // item 91
    return me
}

func  getMyQueue() * MyQueue {
    // item 30
    return &MyQueue {nil,nil,0}
}

func  getQNode(value int) * QNode {
    // item 24
    return &QNode {value,nil}
}

func  getVertices(data int) * Vertices {
    // item 18
    return &Vertices {data,nil,nil}
}

func  main()  {
    // item 4
    var g * Graph = getGraph(6)
    // item 5
    /*
        g.addEdge(0, 1)
        g.addEdge(0, 4)
        g.addEdge(1, 2)
        g.addEdge(1, 5)
        g.addEdge(2, 3)
        g.addEdge(3, 4)
        g.addEdge(4, 5)
        */
        g.addEdge(0, 1)
        g.addEdge(0, 5)
        g.addEdge(1, 1)
        g.addEdge(2, 1)
        g.addEdge(3, 0)
        g.addEdge(3, 3)
        g.addEdge(4, 2)
        g.addEdge(4, 3)
        g.addEdge(5, 1)
    // item 6
    g.printGraph()
    g.bfs(4)
}


