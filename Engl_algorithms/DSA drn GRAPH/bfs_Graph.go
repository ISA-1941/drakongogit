// Autogenerated with DRAKON Editor 1.31

package main
import "fmt"
/*
    Go Program for 
    Breadth first traversal in directed graph
*/
type AjlistNode struct {
    // Vertices node key
    id int
    next * AjlistNode
}
type Vertices struct {
    data int
    next * AjlistNode
    last * AjlistNode
}
type QNode struct {
    data int
    next * QNode
}
type MyQueue struct {
    head * QNode
    tail * QNode
    count int
}
type Graph struct {
    // Число вершин
    size int
    node []* Vertices
}



func  (graph  *Graph) addEdge(start, last int)  {
    // item 125
    if start >= 0 && start < graph.size && 
last >= 0 && last < graph.size {
        // item 128
         var edge * AjlistNode = &AjlistNode {last,nil}
        //getAjlistNode(last)
        // item 129
        if graph.node[start].next == nil {
            // item 132
            graph.node[start].next = edge
        } else {
            // item 133
            graph.node[start].last.next = edge
        }
        // item 212
        graph.node[start].last = edge
    } else {
        // item 137
        fmt.Println("\nHere Something Wrong")
    }
}

func  (graph  *Graph) setData()  {
    // item 95
    if graph.size <= 0 {
        // item 98
        fmt.Println("\nEmpty Graph")
    } else {
        // item 990001
        index := 0;
        for {
            // item 990002
            if index < graph.size {
                
            } else {
                break
            }
            // item 101
            graph.node[index] =
            getVertices(index)
            // item 990003
            index++;
        }
    }
}

func  (graph Graph) bfs(point int)  {
    // item 191
    if point > graph.size || graph.size <= 0 {
        // item 193
        return
    } else {
        
    }
    // item 194
    var que * MyQueue = &MyQueue {nil,nil,0} 
    // getMyQueue()
    // item 232
    var k int = 0
    var p = make([] int, graph.size)
    // item 195
    que.enqueue(point)
    // item 219
    var temp * AjlistNode = nil
    var visit = make([] bool, graph.size)
    for {
        // item 198
        if que.isEmpty() == false {
            
        } else {
            break
        }
        // item 228
        if que.head == nil {
            // item 231
            fmt.Println("Empty Queue")
            return
        } else {
            // item 201
            temp = graph.node[que.head.data].next
        }
        for {
            // item 202
            if temp != nil {
                
            } else {
                break
            }
            // item 205
            if !visit[temp.id] {
                // item 207
                visit[temp.id] = true
                que.enqueue(temp.id)
            } else {
                
            }
            // item 209
            temp = temp.next
        }
        // item 210
        visit[que.head.data] = true
        // item 211
        p[k] = que.dequeue()
        fmt.Println("\np = ", p)
        k++
    }
}

func  (graph Graph) printGraph()  {
    // item 151
    if graph.size > 0 {
        // item 1540001
        index := 0;
        for {
            // item 1540002
            if index < graph.size {
                
            } else {
                break
            }
            // item 156
            fmt.Print("\nAdjacency list of vertex ", 
                            index, " : ")
            // item 157
            var temp * AjlistNode = 
            graph.node[index].next
            for {
                // item 158
                if temp != nil {
                    
                } else {
                    break
                }
                // item 161
                fmt.Print("  ", graph.node[temp.id].data)
                // item 162
                temp = temp.next
            }
            // item 1540003
            index++;
        }
    } else {
        
    }
}

func  (queue  MyQueue) size() int {
    // item 36
    return queue.count
}

func  (queue *MyQueue) dequeue() int {
    // item 61
    if queue.head == nil {
        // item 64
        fmt.Println("Empty Queue")
        return -1
    } else {
        
    }
    // item 65
    var temp * QNode = queue.head
    // item 66
    queue.head = queue.head.next
    queue.count--
    // item 69
    if queue.head == nil {
        // item 72
        queue.tail = nil
    } else {
        
    }
    // item 73
    return temp.data
}

func  (queue *MyQueue) enqueue(value int)  {
    // item 48
    var node * QNode = &QNode {value,nil}
    // item 49
    if queue.head == nil {
        // item 52
        queue.head = node
    } else {
        // item 53
        queue.tail.next = node
    }
    // item 54
    queue.count++
    // item 55
    queue.tail = node
}

func  (queue MyQueue) isEmpty() bool {
    // item 42
     return queue.count == 0
}

func  (queue MyQueue) peek() int {
    // item 79
    if queue.head == nil {
        // item 82
        fmt.Println("Empty Queue")
        return -1
    } else {
        // item 83
        return queue.head.data
    }
}

func  getAjlistNode(id int) *AjlistNode {
    // item 12
    return &AjlistNode {id,nil}
}

func  getGraph(size int) * Graph {
    // item 89
    var me *Graph = 
    &Graph {size,make([]*Vertices, size)}
    // item 90
    me.setData()
    // item 91
    return me
}

func  getMyQueue() * MyQueue {
    // item 30
    return &MyQueue {nil,nil,0}
}

func  getQNode(value int) * QNode {
    // item 24
    return &QNode {value,nil}
}

func  getVertices(data int) * Vertices {
    // item 18
    return &Vertices {data,nil,nil}
}

func  main()  {
    // item 4
    var graph * Graph = getGraph(6)
    // item 5
    graph.addEdge(0, 1)
    graph.addEdge(0, 5)
    graph.addEdge(1, 1)
    graph.addEdge(2, 1)
    graph.addEdge(3, 0)
    graph.addEdge(3, 3)
    graph.addEdge(4, 2)
    graph.addEdge(4, 3)
    graph.addEdge(5, 1)
    // item 233
    graph.printGraph()
    graph.bfs(4)
}


