// Autogenerated with DRAKON Editor 1.31

package main
import "fmt"

/*
    Go program for 
    DFS traversal of directed graph using recursion
*/

type AjlistNode struct {
    // Vertices node key
    id int
    next * AjlistNode

}

type Vertices struct {
    data int
    next * AjlistNode
    last * AjlistNode
}

type Graph struct {
    // Number of Vertices
    size int
    node []*Vertices
}



func  (g *Graph)  setData()  {
    // item 35
    if g.size <= 0 {
        // item 38
        fmt.Println("\nEmpty Graph")
    } else {
        // item 390001
        index := 0;
        for {
            // item 390002
            if index < g.size {
                
            } else {
                break
            }
            // item 41
            g.node[index] = getVertices(index)
            // item 390003
            index++;
        }
    }
}

func  (g *Graph) addEdge(start, last int)  {
    // item 50
    var last1, last2 bool
    // item 51
    last1 = start >= 0 && start < g.size
    last2 = last >= 0 && last < g.size
    // item 47
    if last1 && last2 {
        // item 52
        g.connect(start, last)
    } else {
        // item 53
        fmt.Println("\n  Что-то пошло не так")
    }
}

func  (g *Graph) connect(start, last int)  {
    // item 98
     var edge * AjlistNode =
     getAjlistNode(last)
    // item 99
    if g.node[start].next == nil {
        // item 101
        g.node[start].next = edge
    } else {
        // item 103
        g.node[start].last.next = edge
    }
    // item 104
    g.node[start].last = edge
}

func  (g Graph) printGraph()  {
    // item 57
    if g.size > 0 {
        // item 600001
        index := 0;
        for {
            // item 600002
            if index < g.size {
                
            } else {
                break
            }
            // item 62
           fmt.Print("\nAdjacency list of vertex ", index, " :")
            // item 63
            var temp * AjlistNode = g.node[index].next
             //fmt.Println("\n     printGraph: temp = ", temp)
            for {
                // item 64
                if temp != nil {
                    
                } else {
                    break
                }
                // item 66
                fmt.Print("  ", g.node[temp.id].data)
                // item 67
                temp = temp.next
            }
            // item 600003
            index++;
        }
    } else {
        
    }
}

func  getAjlistNode(key int) * AjlistNode {
    // item 23
    return &AjlistNode {key, nil}
}

func  getGraph(size int) * Graph {
    // item 120
    var myGraph *Graph
    // item 29
    myGraph = &Graph {size,make([]*Vertices, size)}
    //fmt.Println("getGraph1: myGraph = ", myGraph)
    // item 30
    myGraph.setData()
    fmt.Println("getGraph2: myGraph = ", myGraph)
    // item 31
    return myGraph
}

func  getVertices(data int) *Vertices {
    // item 92
    return &Vertices {data, nil, nil}
}

func  main()  {
    // item 108
    // 6 реализаций узлов 
    // https://kalkicode.com/dfs-traversal-of-directed-graph-in-go
	var g *Graph = getGraph(5)
    g.addEdge(0, 1)
    g.addEdge(0, 4)
    g.addEdge(1, 2)
    g.addEdge(1, 5)
    g.addEdge(2, 3)
    g.addEdge(3, 4)
    g.addEdge(4, 5)
	g.printGraph()
	fmt.Print("\nDFS :\n")
	//g.printDFS(0)
    }


