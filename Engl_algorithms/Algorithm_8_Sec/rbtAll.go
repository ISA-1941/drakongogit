// Autogenerated with DRAKON Editor 1.31

package main

import "fmt"

type RBTree struct {
	root     *Node
	nullNode *Node
}

func NewRBTree() (rbt *RBTree) {
	rbt = &RBTree{}
	rbt.nullNode = NewNode(0, nil)
	rbt.nullNode.colour = false
	rbt.root = rbt.nullNode
	return
}

type Node struct {
	data                int
	colour              bool // true for red colour, false for black colour
	left, right, parent *Node
}


func  (rbt *RBTree) balanceDeleteNode(node *Node)  {
    // item 209
    if node == rbt.root {
        // item 212
        return
    } else {
        
    }
    // item 213
    sib := rbt.sibling(node)
    parent := node.parent
    // item 214
    if sib == rbt.nullNode {
        // item 217
        rbt.balanceDeleteNode(parent)
    } else {
        // item 2180001
        if sib.colour == true {
            // item 225
            parent.colour = true
            sib.colour = false
            // item 226
            if sib.parent.left == sib {
                // item 229
                rbt.rightRotate(parent)
            } else {
                // item 230
                rbt.leftRotate(parent)
            }
            // item 231
            rbt.balanceDeleteNode(node)
        } else {
            // item 2180002
            if sib.left.colour == true ||
 sib.right.colour == true {
                // item 232
                if sib.parent.left == sib {
                    // item 235
                    if sib.left != rbt.nullNode && 
sib.left.colour == true {
                        // item 238
                        sib.left.colour = sib.colour
                        sib.colour = parent.colour
                        rbt.rightRotate(parent)
                    } else {
                        // item 239
                        sib.right.colour = parent.colour
                        rbt.leftRotate(sib)
                        rbt.rightRotate(parent)
                    }
                    // item 245
                    parent.colour = false
                } else {
                    // item 240
                    if sib.left != rbt.nullNode && 
sib.left.colour == true {
                        // item 243
                        sib.left.colour = parent.colour
                        rbt.rightRotate(sib)
                        rbt.leftRotate(parent)
                    } else {
                        // item 244
                        sib.right.colour = sib.colour
                        sib.colour = parent.colour
                        rbt.leftRotate(parent)
                    }
                }
            } else {
                // item 248
                sib.colour = true
                // item 249
                if parent.colour == false {
                    // item 252
                    rbt.balanceDeleteNode(parent)
                } else {
                    // item 253
                    parent.colour = false
                }
            }
        }
    }
}

func  (rbt *RBTree) balanceInsert(node *Node)  {
    // item 159
    if node == rbt.root {
        // item 162
        node.colour = false
        // item 163
        return
    } else {
        
    }
    // item 164
    if node.parent == rbt.nullNode ||
 node.parent.parent == rbt.nullNode {
        // item 167
        return
    } else {
        
    }
    // item 168
    parent := node.parent
    // item 169
    GP := parent.parent
    // item 170
    uncle := rbt.uncle(node)
    // item 171
    var mid *Node = nil
    // item 172
    if parent.colour == false {
        // item 175
        return
    } else {
        
    }
    // item 176
    if uncle != rbt.nullNode && 
uncle.colour == true {
        // item 179
        parent.colour = false
        // item 180
        uncle.colour = false
        // item 181
        GP.colour = true
        // item 182
        rbt.balanceInsert(GP)
        // item 183
        return
    } else {
        
    }
    // item 1870001
    if parent == GP.left && 
node == parent.left {
        // item 194
        mid = rbt.rightRotate(GP)
    } else {
        // item 1870002
        if parent == GP.left && 
node == parent.right {
            // item 197
            mid = 
            rbt.leftRightRotate(GP)
        } else {
            // item 1870003
            if parent == GP.right && 
node == parent.left {
                // item 198
                mid = 
                rbt.rightLeftRotate(GP)
            } else {
                // item 1870004
                if parent == GP.right && 
node == parent.right {
                    // item 199
                    mid = 
                    rbt.leftRotate(GP)
                } else {
                    // item 397
                    fmt.Println(" Empty ")
                }
            }
        }
    }
    // item 201
    mid.colour = false
    // item 202
    mid.left.colour = true
    // item 203
    mid.right.colour = true
}

func  (rbt *RBTree) delete(data int)  {
    // item 298
    rbt.deleteNode(rbt.root, data)
}

func  (rbt *RBTree) deleteNode(node *Node, key int)  {
    // item 332
    z := rbt.nullNode
    var x *Node
    var y *Node
    for {
        // item 333
        if node != rbt.nullNode {
            
        } else {
            break
        }
        // item 3670001
        if node.data == key {
            // item 339
            z = node
            break
        } else {
            // item 3670002
            if node.data <= key {
                // item 343
                node = node.right
            } else {
                // item 3670003
                if node.data > key {
                    
                } else {
                    // item 3670004
                    panic("Not expected condition.")
                }
                // item 344
                node = node.left
            }
        }
    }
    // item 345
    if z == rbt.nullNode {
        // item 348
        fmt.Println("Couldn't find key in the tree")
        return
    } else {
        
    }
    // item 349
    y = z
    yColour := y.colour
    // item 350
    if z.left == rbt.nullNode {
        // item 353
        x = z.right
        rbt.joinParentChild(z, z.right)
    } else {
        // item 354
        if z.right == rbt.nullNode {
            // item 357
            x = z.left
            rbt.joinParentChild(z, z.left)
        } else {
            // item 358
            y = rbt.minimum(z.right)
            yColour = y.colour
            z.data = y.data
            rbt.joinParentChild(y, y.right)
            x = y.right
        }
    }
    // item 359
    if yColour == false {
        // item 362
        if x.colour == true {
            // item 365
            x.colour = false
            return
        } else {
            // item 366
            rbt.balanceDeleteNode(x)
        }
    } else {
        
    }
}

func  (rbt *RBTree) find(data int) *Node {
    // item 129
    curr := rbt.root
    for {
        // item 130
        if curr != rbt.nullNode {
            
        } else {
            break
        }
        // item 1330001
        if curr.data == data {
            // item 141
            return curr
        } else {
            // item 1330002
            if curr.data > data {
                // item 142
                curr = curr.left
            } else {
                // item 1330003
                if curr.data < data {
                    
                } else {
                    // item 1330004
                    panic("Not expected condition.")
                }
                // item 143
                curr = curr.right
            }
        }
    }
    // item 144
    return nil
}

func  (rbt *RBTree) insert(data int)  {
    // item 102
    rbt.root = rbt.insertNode(rbt.root, data)
    // item 103
    temp := rbt.find(data)
    // item 104
    rbt.balanceInsert(temp)
}

func  (rbt *RBTree) insertNode(node *Node, data int) *Node {
    // item 1100001
    if node == rbt.nullNode {
        // item 117
        node = NewNode(data, rbt.nullNode)
    } else {
        // item 1100002
        if node.data > data {
            // item 118
            node.left = 
            rbt.insertNode(node.left, data)
            // item 119
            node.left.parent = node
        } else {
            // item 1100003
            if node.data < data {
                
            } else {
                // item 1100004
                panic("Not expected condition.")
            }
            // item 120
            node.right = 
            rbt.insertNode(node.right, data)
            // item 121
            node.right.parent = node
        }
    }
    // item 123
    return node
}

func  (rbt *RBTree) isRed(node *Node) bool {
    // item 15
    if node == nil {
        // item 18
        return false
    } else {
        
    }
    // item 19
    return (node.colour == true)
}

func  (rbt *RBTree) joinParentChild(u, v *Node)  {
    // item 273
    if u.parent == rbt.nullNode {
        // item 276
        rbt.root = v
    } else {
        // item 277
        if u == u.parent.left {
            // item 280
            u.parent.left = v
        } else {
            // item 281
            u.parent.right = v
        }
    }
    // item 282
    v.parent = u.parent
}

func  (rbt *RBTree) leftRightRotate(node *Node) *Node {
    // item 95
    node.left = rbt.leftRotate(node.right)
    // item 96
    return rbt.rightRotate(node)
}

func  (rbt *RBTree) leftRotate(x *Node) *Node {
    // item 531
    y := x.right
    t := y.left
    // item 532
    y.parent = x.parent
    y.left = x
    x.parent = y
    x.right = t
    // item 535
    if t != rbt.nullNode {
        // item 533
        t.parent = x
    } else {
        
    }
    // item 538
    if x == rbt.root {
        // item 534
        rbt.root = y
        return y
    } else {
        
    }
    // item 541
    if y.parent.left == x {
        // item 543
        y.parent.left = y
    } else {
        // item 544
        y.parent.right = y
    }
    // item 545
    return y
}

func  (rbt *RBTree) leftRotateOld(x *Node) *Node {
    // item 68
    y := x.right
    T := y.left
    // item 69
    y.parent = x.parent
    y.left = x
    x.parent = y
    x.right = T
    // item 72
    if T != rbt.nullNode {
        // item 70
        T.parent = x
    } else {
        
    }
    // item 75
    if x == rbt.root {
        // item 71
        rbt.root = y
        return y
    } else {
        
    }
    // item 78
    if y.parent.left == x {
        // item 81
        y.parent.left = y
    } else {
        // item 82
        y.parent.right = y
    }
    // item 391
    return y
}

func  (rbt *RBTree) minimum(node *Node) *Node {
    for {
        // item 288
        if node.left != rbt.nullNode {
            
        } else {
            break
        }
        // item 291
        node = node.left
    }
    // item 292
    return node
}

func  (rbt *RBTree) printTree()  {
    // item 402
    rbt.printTreeNode(rbt.root, "", false)
    fmt.Println()
}

func  (rbt *RBTree) printTreeNode(node *Node, indent string, isLeft bool)  {
    // item 380
    if node == rbt.nullNode {
        // item 383
        return
    } else {
        
    }
    // item 384
    if isLeft {
        // item 387
        fmt.Print(indent, "L:")
        indent += "|  "
    } else {
        // item 388
        fmt.Print(indent, "R:")
        indent += "   "
    }
    // item 389
    fmt.Println(node.data,
     "(", node.colour, ")")
    rbt.printTreeNode(node.left,
    indent, true)
    rbt.printTreeNode(node.right, 
    indent, false)
}

func  (rbt *RBTree) rightLeftRotate(node *Node) *Node {
    // item 88
    node.right = rbt.rightRotate(node.right)
    // item 89
    return rbt.leftRotate(node)
}

func  (rbt *RBTree) rightRotate(x *Node) *Node {
    // item 501
    y := x.left
    t := y.right
    // item 502
    y.parent = x.parent
    y.right = x
    x.parent = y
    x.left = t
    // item 504
    if t != rbt.nullNode {
        // item 503
        t.parent = x
    } else {
        
    }
    // item 508
    if x == rbt.root {
        // item 507
        rbt.root = y
        return y
    } else {
        
    }
    // item 511
    if y.parent.left == x {
        // item 514
        y.parent.left = y
    } else {
        // item 515
        y.parent.right = y
    }
    // item 516
    return y
}

func  (rbt *RBTree) rightRotateOld(x *Node) *Node {
    // item 40
    y := x.left
    t := y.right
    // item 41
    y.parent = x.parent
    y.right = x
    x.parent = y
    x.left = t
    // item 51
    if t != rbt.nullNode {
        // item 49
        t.parent = x
    } else {
        
    }
    // item 54
    if x == rbt.root {
        // item 50
        rbt.root = y
        return y
    } else {
        
    }
    // item 57
    if y.parent.left == x {
        // item 60
        y.parent.left = y
    } else {
        // item 61
        y.parent.right = y
    }
    // item 392
    return y
}

func  (rbt *RBTree) sibling(node *Node) *Node {
    // item 259
    if node.parent == rbt.nullNode {
        // item 262
        return nil
    } else {
        
    }
    // item 263
    if node.parent.left == node {
        // item 266
        return node.parent.right
    } else {
        
    }
    // item 267
    return node.parent.left
}

func  (rbt *RBTree) uncle(node *Node) *Node {
    // item 27
    if  node.parent == rbt.nullNode || 
node.parent.parent == rbt.nullNode {
        // item 26
        return nil
    } else {
        
    }
    // item 30
    if node.parent == 
node.parent.parent.left {
        // item 33
        return node.parent.parent.right
    } else {
        // item 34
        return node.parent.parent.left
    }
}

func  main()  {
    // item 5
    tree := NewRBTree()
    // item 4
    values := []int {21,17,15,11,9,7,5,3}
    // item 80001
    i := 0;
    for {
        // item 80002
        if i < len(values) {
            
        } else {
            break
        }
        // item 7
        tree.insert(values[i])
        // item 80003
        i++;
    }
    // item 398
    tree.printTree()
    tree.delete(17)
    tree.printTree()
    tree.delete(15)
    tree.printTree()
}

func NewNode(d int, nullNode *Node) (nd *Node) {
	nd = &Node{}
	nd.data = d
	nd.left = nullNode
	nd.right = nullNode
	nd.parent = nullNode
	nd.colour = true // New node are red in colour.
	return
}
