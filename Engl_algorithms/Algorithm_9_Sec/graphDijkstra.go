// Autogenerated with DRAKON Editor 1.31

package main

import (
	"fmt"
	"math"
)

type Graph struct {
	vertices []*Vertex
}

type Vertex struct {
	key      int
	adjacent []*Vertex
	lengths  []float64
	dist     float64
}


func  (graph *Graph) Dijkstra(startKey int)  {
    // item 60
    startVertex := graph.getVertex(startKey)
    startVertex.dist = 0
    // item 62
    unvisited := 
    make([]*Vertex, len(graph.vertices))
    copy(unvisited, graph.vertices)
    for {
        // item 63
        if len(unvisited) != 0 {
            
        } else {
            break
        }
        // item 66
        smallest := 
        findSmallest(unvisited)
        // item 120
        unvisited = 
        remove(unvisited, smallest)
        for i := range smallest.adjacent {
            // item 69
            alt := smallest.dist + 
            smallest.lengths[i]
            // item 70
            if alt < smallest.adjacent[i].dist {
                // item 73
                smallest.adjacent[i].dist = alt
            } else {
                
            }
        }
    }
}

func  (graph *Graph) addEdge(from, to int, length float64)  {
    // item 105
    fromVertex := graph.getVertex(from)
    toVertex := graph.getVertex(to)
    // item 106
    fromVertex.adjacent = 
    append(fromVertex.adjacent, toVertex)
    // item 113
    fromVertex.lengths = 
    append(fromVertex.lengths, length)
}

func  (graph *Graph) addSymEdge(u int, v int, w float64)  {
    // item 119
    graph.addEdge(u, v, w)
    graph.addEdge(v, u, w)
}

func  (graph *Graph) addVertex(key int)  {
    // item 24
    v := newVertex(key)
    // item 25
    graph.vertices = 
    append(graph.vertices, v)
}

func  (graph *Graph) getVertex(key int) *Vertex {
    // item 310001
    i := 0;
    for {
        // item 310002
        if i < len(graph.vertices) {
            
        } else {
            break
        }
        // item 33
        if graph.vertices[i].key == key {
            // item 36
            return graph.vertices[i]
        } else {
            
        }
        // item 310003
        i++;
    }
    // item 37
    return nil
}

func  findSmallest(vertices []*Vertex) *Vertex {
    // item 79
    smallest := vertices[0]
    for i := range vertices {
        // item 82
        if vertices[i].dist < smallest.dist {
            // item 85
            smallest = vertices[i]
        } else {
            
        }
    }
    // item 86
    return smallest
}

func  main()  {
    // item 4
    graph := &Graph{}
    size := 6
    // item 50001
    i := 0;
    for {
        // item 50002
        if i < size {
            
        } else {
            break
        }
        // item 7
        graph.addVertex(i)
        // item 50003
        i++;
    }
    // item 8
    graph.addSymEdge(0, 1, 37.5)
    graph.addSymEdge(0, 2, 40.2)
    graph.addSymEdge(0, 5, 48.3)
    graph.addSymEdge(1, 2, 30.7)
    graph.addSymEdge(1, 3, 42.6)
    graph.addSymEdge(2, 3, 29.8)
    graph.addSymEdge(2, 5, 23.4)
    graph.addSymEdge(4, 3, 25.4)
    graph.addSymEdge(4, 5, 34.9)
    // item 9
    graph.Dijkstra(4)
    // item 100001
    j := 0;
    for {
        // item 100002
        if j < len(graph.vertices) {
            
        } else {
            break
        }
        // item 12
        fmt.Printf("Distance from start to %d is %.2f km\n",
        graph.vertices[j].key, graph.vertices[j].dist)
        // item 100003
        j++;
    }
}

func  newVertex(key int) *Vertex {
    // item 18
    return &Vertex{
    key:      key,
    adjacent: []*Vertex{},
    lengths:  []float64{},
    dist:     math.MaxFloat64,
    }
}

func  remove(vertices []*Vertex, vertex *Vertex) []*Vertex {
    // item 92
    index := -1
    // item 930001
    i := 0;
    for {
        // item 930002
        if i < len(vertices) {
            
        } else {
            break
        }
        // item 95
        if vertices[i] == vertex {
            // item 98
            index = i
        } else {
            
        }
        // item 930003
        i++;
    }
    // item 99
    return append(vertices[:index], 
    vertices[index+1:]...)
}


